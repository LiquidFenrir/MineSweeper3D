; Example PICA200 geometry shader
.gsh point c0

; Uniforms
.fvec projection[4]
.fvec cameraPos ; x, y location + z, w pitch, yaw

; Constants
.constf myconst(0.0, 1.0, -1.0, 0.5)
.alias  zeros myconst.xxxx ; Vector full of zeros
.alias  ones  myconst.yyyy ; Vector full of ones
.alias  half  myconst.wwww

; Outputs - this time the type *is* used
.out outpos position
.out outtex texcoord0

; Inputs: we will receive the following inputs:
; v0: position (x,y,z,texnum)
; v1-v2: direction of the top left and top right points to use
; v3-v4: axes for symmetry of the aforementioned points

.entry gmain
.proc gmain
	; Emit the first triangle
	mov r0, v0 ; r0 contains (+x,0)
	mov r1, v0 ; r1 contains (0,0)
	mov r2, v0 ; r2 contains (0,+z)
	call emit_triangle

	; Emit the second triangle
	mov r0, v0 ; r0 contains (+x,0)
	mov r1, r2 ; r1 contains (0,+z)
	mov r2, v0 ; r2 contains (+x,+z)
	call emit_triangle

	; We're finished
	end
.end

.proc emit_triangle
	; Emit the first vertex
	setemit 0
	mov r8, r0
	mov r9, v1
	call process_vertex
	emit

	; Emit the second vertex
	setemit 1
	mov r8, r1
	mov r9, v3
	call process_vertex
	emit

	; Emit the third vertex and finish the primitive
	setemit 2, prim
	mov r8, r2
	mov r9, v5
	call process_vertex
	emit
.end

; Subroutine
; Inputs:
;   r8: vertex position
.proc process_vertex
	mov outtex.xy, 
	; outpos = projectionMatrix * r8
	dp4 outpos.x, projection[0], r8.xyzz
	dp4 outpos.y, projection[1], r8.xyzz
	dp4 outpos.z, projection[2], r8.xyzz
	dp4 outpos.w, projection[3], r8.xyzz

	; outclr = r9
.end
